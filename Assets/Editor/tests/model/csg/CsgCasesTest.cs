// Copyright 2020 The Blocks Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using NUnit.Framework;
using UnityEngine;
using com.google.apps.peltzer.client.model.core;

/// <summary>
/// Several various csg test cases. These were generated by placing logging in
/// volume inserter and copying over info about shapes when csg errors happened.
///
/// With full logging turned on, these test cases shouldn't produce any errors.
///
/// It's useful to run these test cases in the app as well (copy them
/// into a coroutine in PeltzerMain). It makes it easy to
/// spot obvious problems.
/// </summary>
namespace com.google.apps.peltzer.client.model.csg {
  [TestFixture]
  public class CsgCasesTest {
    [Test]
    public void TestOne() {
      Vector3 scale1 = new Vector3(0.06f, 0.06f, 0.06f);
      Vector3 offset1 = new Vector3(-0.2588203f, 0.7604792f, 0.08228087f);
      Quaternion rot1 = Quaternion.Euler(337.6894f, 345.5614f, 303.5857f);

      Vector3 scale2 = new Vector3(0.03f, 0.03f, 0.03f);
      Vector3 offset2 = new Vector3(-0.2294091f, 0.7091361f, 0.06302771f);
      Quaternion rot2 = Quaternion.Euler(355.6298f, 5.137078f, 291.4288f);

      MMesh shape1 = Primitives.AxisAlignedBox(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedCylinder(1, Vector3.zero, scale2, null, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestTwo() {
      Vector3 scale1 = new Vector3(0.05f, 0.05f, 0.05f);
      Vector3 offset1 = new Vector3(-0.3578773f, 0.7828305f, -0.02011965f);
      Quaternion rot1 = Quaternion.Euler(341.5305f, 311.4361f, 350.6624f);

      Vector3 scale2 = new Vector3(0.04f, 0.04f, 0.04f);
      Vector3 offset2 = new Vector3(-0.3189396f, 0.741451f, -0.01238456f);
      Quaternion rot2 = Quaternion.Euler(337.015f, 341.9556f, 302.1871f);

      MMesh shape1 = Primitives.AxisAlignedBox(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedCylinder(1, Vector3.zero, scale2, null, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestThree() {
      Vector3 scale1 = new Vector3(0.09f, 0.09f, 0.09f);
      Vector3 offset1 = new Vector3(-0.4822676f, 0.840179f, -0.2138236f);
      Quaternion rot1 = Quaternion.Euler(325.8044f, 269.0391f, 340.9526f);

      Vector3 scale2 = new Vector3(0.04f, 0.04f, 0.04f);
      Vector3 offset2 = new Vector3(-0.3975593f, 0.8605151f, -0.1950957f);
      Quaternion rot2 = Quaternion.Euler(327.2958f, 267.8308f, 343.3483f);

      MMesh shape1 = Primitives.AxisAlignedBox(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedBox(1, Vector3.zero, scale2, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestFour() {
      Vector3 scale1 = new Vector3(0.09f, 0.09f, 0.09f);
      Vector3 offset1 = new Vector3(-0.3445286f, 0.7810592f, 0.1000385f);
      Quaternion rot1 = Quaternion.Euler(335.4548f, 326.2354f, 311.7785f);

      Vector3 scale2 = new Vector3(0.03f, 0.03f, 0.03f);
      Vector3 offset2 = new Vector3(-0.2409048f, 0.8018835f, 0.05735187f);
      Quaternion rot2 = Quaternion.Euler(329.2861f, 336.1176f, 314.4811f);

      MMesh shape1 = Primitives.AxisAlignedBox(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedIcosphere(1, Vector3.zero, scale2, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestFive() {
      Vector3 scale1 = new Vector3(0.04f, 0.04f, 0.04f);
      Vector3 offset1 = new Vector3(-0.3964509f, 0.8120602f, -0.03975228f);
      Quaternion rot1 = Quaternion.Euler(328.3585f, 286.2379f, 348.8317f);

      Vector3 scale2 = new Vector3(0.03f, 0.03f, 0.03f);
      Vector3 offset2 = new Vector3(-0.3812525f, 0.8245335f, -0.03840983f);
      Quaternion rot2 = Quaternion.Euler(331.8435f, 304.2563f, 339.4354f);

      MMesh shape1 = Primitives.AxisAlignedBox(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedIcosphere(1, Vector3.zero, scale2, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestSix() {
      Vector3 scale1 = new Vector3(0.06f, 0.06f, 0.06f);
      Vector3 offset1 = new Vector3(-0.2539979f, 0.8296162f, -0.01753259f);
      Quaternion rot1 = Quaternion.Euler(323.3995f, 335.1265f, 290.1707f);

      Vector3 scale2 = new Vector3(0.03f, 0.03f, 0.03f);
      Vector3 offset2 = new Vector3(-0.2052484f, 0.8434253f, -0.02635695f);
      Quaternion rot2 = Quaternion.Euler(317.0431f, 355.3317f, 294.1518f);

      MMesh shape1 = Primitives.AxisAlignedIcosphere(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedCylinder(1, Vector3.zero, scale2, null, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestSeven() {
      Vector3 scale1 = new Vector3(0.09f, 0.09f, 0.09f);
      Vector3 offset1 = new Vector3(-0.3976895f, 0.8503361f, -0.167705f);
      Quaternion rot1 = Quaternion.Euler(314.5735f, 284.1546f, 350.7589f);
      Vector3 scale2 = new Vector3(0.14f, 0.14f, 0.14f);
      Vector3 offset2 = new Vector3(-0.3232127f, 0.9357966f, -0.182199f);
      Quaternion rot2 = Quaternion.Euler(307.9687f, 283.914f, 348.6634f);

      MMesh shape1 = Primitives.AxisAlignedBox(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedBox(1, Vector3.zero, scale2, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestEight() {
      Vector3 scale1 = new Vector3(0.17f, 0.17f, 0.17f);
      Vector3 offset1 = new Vector3(-0.4381654f, 0.8735071f, -0.2654698f);
      Quaternion rot1 = Quaternion.Euler(324.5257f, 267.3036f, 1.283594f);
      Vector3 scale2 = new Vector3(0.18f, 0.18f, 0.18f);
      Vector3 offset2 = new Vector3(-0.4458212f, 0.8969067f, -0.2600397f);
      Quaternion rot2 = Quaternion.Euler(323.0872f, 274.6339f, 355.8188f);

      MMesh shape1 = Primitives.AxisAlignedBox(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedBox(1, Vector3.zero, scale2, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestNine() {
      Vector3 scale1 = new Vector3(0.09999999f, 0.09999999f, 0.09999999f);
      Vector3 offset1 = new Vector3(-0.2459444f, 0.8127318f, -0.02276482f);
      Quaternion rot1 = Quaternion.Euler(323.0423f, 342.4444f, 312.1532f);

      Vector3 scale2 = new Vector3(0.05f, 0.05f, 0.05f);
      Vector3 offset2 = new Vector3(-0.1958988f, 0.755046f, 0.02580362f);
      Quaternion rot2 = Quaternion.Euler(333.4003f, 346.5612f, 333.1861f);

      MMesh shape1 = Primitives.Torus(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.AxisAlignedIcosphere(1, Vector3.zero, scale2, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }

    [Test]
    public void TestTen() {
      Vector3 scale1 = new Vector3(0.13f, 0.13f, 0.13f);
      Vector3 offset1 = new Vector3(-0.3696883f, 0.8180166f, 0.09428416f);
      Quaternion rot1 = Quaternion.Euler(329.1212f, 310.4952f, 342.6105f);

      Vector3 scale2 = new Vector3(0.2f, 0.2f, 0.2f);
      Vector3 offset2 = new Vector3(-0.3002505f, 0.8771363f, 0.1747152f);
      Quaternion rot2 = Quaternion.Euler(327.2445f, 318.5047f, 26.39776f);

      MMesh shape1 = Primitives.AxisAlignedIcosphere(0, Vector3.zero, scale1, 1);
      shape1.offset = offset1;
      shape1.rotation = rot1;
      MMesh shape2 = Primitives.Torus(1, Vector3.zero, scale2, 2);
      shape2.offset = offset2;
      shape2.rotation = rot2;

      Bounds bounds = new Bounds(Vector3.zero, Vector3.one * 10.0f);
      SpatialIndex spatialIndex = new SpatialIndex(bounds);
      spatialIndex.AddMesh(shape1);
      Model m = new Model(bounds);
      m.AddMesh(shape1);

      NUnit.Framework.Assert.IsTrue(CsgOperations.SubtractMeshFromModel(m, spatialIndex, shape2));
    }
  }
}