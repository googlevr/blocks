// Copyright 2020 The Blocks Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using com.google.apps.peltzer.client.model.core;
using com.google.apps.peltzer.client.model.main;
using com.google.apps.peltzer.client.model.util;
using com.google.apps.peltzer.client.serialization;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace com.google.apps.peltzer.client.model.export
{
    // The top-level definition of a Peltzer file, and subject classes: go/peltzer-file-format
    public class PeltzerFile
    {
        /// <summary>
        /// File format version when serializing via PolySerializer. Increase this when making incompatible changes to
        /// the serialization format, that is, when making changes that older versions won't be able to parse.
        ///
        /// Remember that small (additive) changes do not need a file format version change, as you can just
        /// add new chunks to PolySerializer that will be skipped by older versions.
        /// 
        /// This version number should be increased RARELY. Most incremental file format changes should be
        /// implemented as new chunks in PolySerializer that can be safely ignored by older versions.
        /// Remember that if you increment this, files generated by your new version WILL NOT LOAD AT ALL in
        /// older Poly versions.
        /// </summary>
        private const int FILE_FORMAT_VERSION = 1;

        public Metadata metadata;
        public float zoomFactor;
        public List<PeltzerMaterial> materials;
        public List<MMesh> meshes;

        public PeltzerFile(Metadata metadata, float zoomFactor, List<PeltzerMaterial> materials,
          List<MMesh> meshes)
        {
            this.metadata = metadata;
            this.zoomFactor = zoomFactor;
            this.materials = materials;
            this.meshes = meshes;
        }

        /// <summary>
        // Serialize to PolySerializer.
        /// </summary>
        /// <param name="includeDisplayRotation">Whether or not to include the recommended model display rotation
        /// in save.</param>
        public void Serialize(PolySerializer serializer, bool includeDisplayRotation = false)
        {
            serializer.StartWritingChunk(SerializationConsts.CHUNK_PELTZER);
            serializer.WriteInt(FILE_FORMAT_VERSION);
            serializer.WriteString(metadata.creatorName);
            serializer.WriteString(metadata.creationDate);
            serializer.WriteString(metadata.version);
            serializer.WriteFloat(zoomFactor);
            serializer.WriteCount(materials.Count);
            for (int i = 0; i < materials.Count; i++)
            {
                serializer.WriteInt(materials[i].materialId);
                serializer.WriteInt(materials[i].color);
            }
            serializer.WriteCount(meshes.Count);
            serializer.FinishWritingChunk(SerializationConsts.CHUNK_PELTZER);

            // Write the meshes. Each mesh is written as a separate chunk.
            for (int i = 0; i < meshes.Count; i++)
            {
                meshes[i].Serialize(serializer);
            }

            // Write the angle of rotation of the model that orients it towards the user, for a more intelligent
            // rotation on the Poly menu when this model is loaded.
            if (includeDisplayRotation)
            {
                Vector3 centroid = Math3d.FindCentroid(meshes);
                float recommendedRotation = GetUserFacingModelRotation(PeltzerMain.Instance.worldSpace.ModelToWorld(centroid));

                // Write rotation to new chunk.
                serializer.StartWritingChunk(SerializationConsts.CHUNK_PELTZER_EXT_MODEL_ROTATION);
                serializer.WriteFloat(recommendedRotation);
                serializer.FinishWritingChunk(SerializationConsts.CHUNK_PELTZER_EXT_MODEL_ROTATION);
            }
        }

        /// <summary>
        /// Returns the rotation about the y-axis that maintains the current orientation between the user
        /// and the model, accounting for world space rotation.
        /// </summary>
        /// <param name="centroid">The centroid of the model, in world-space coordinates.</param>
        float GetUserFacingModelRotation(Vector3 centroid)
        {
            // Calculate the desired forward; in this case, the relative position of the centroid to the camera.
            Vector3 relativePos = centroid - PeltzerMain.Instance.eyeCameraPosition;
            Quaternion rotationAngle = Quaternion.LookRotation(relativePos);
            // Negate the rotation to get the correct forward for the model when positioned on the menu,
            // such that it maintains its orientation towards the user. Use only the Y-axis rotation because
            // worldspace is fixed on the y-axis, so the majority of models will have the correct up orientation.
            rotationAngle.eulerAngles = new Vector3(0f, -rotationAngle.eulerAngles.y, 0f);
            rotationAngle *= PeltzerMain.Instance.worldSpace.rotation;
            return rotationAngle.eulerAngles.y;
        }

        /// <summary>
        /// Gets a (generous) estimate on how large the serialized file will be.
        /// Although not 100% guaranteed, this is designed to OVERESTIMATE the size, such that if this value is
        /// used to allocate a buffer, the buffer should be large enough to hold the serialization so there shouldn't
        /// be a need to re-allocate it.
        /// </summary>
        /// <returns>The (over-)estimated size of the serialized file.</returns>
        public int GetSerializedSizeEstimate()
        {
            int estimate =
              // A more than generous estimate for headers, metadata and such:
              32768 +
              // Materials are 2 ints each:
              materials.Count() * 8;

            // Calculate estimate for meshes:
            for (int i = 0; i < meshes.Count; i++)
            {
                estimate += meshes[i].GetSerializedSizeEstimate();
            }

            // TODO: estimate size of commands as well.

            return estimate;
        }

        // Deserialize from PolySerializer.
        public PeltzerFile(PolySerializer serializer)
        {
            serializer.StartReadingChunk(SerializationConsts.CHUNK_PELTZER);
            int formatVersion = serializer.ReadInt();
            AssertOrThrow.True(formatVersion == FILE_FORMAT_VERSION,
              "Wrong file format version: " + formatVersion + ", expected " + FILE_FORMAT_VERSION);
            string creatorName = serializer.ReadString();
            string creationDate = serializer.ReadString();
            string version = serializer.ReadString();
            metadata = new Metadata(creatorName, creationDate, version);
            zoomFactor = serializer.ReadFloat();

            int materialCount = serializer.ReadCount(0, SerializationConsts.MAX_MATERIALS_PER_FILE, "materialCount");
            materials = new List<PeltzerMaterial>(materialCount);
            for (int i = 0; i < materialCount; i++)
            {
                int materialId = serializer.ReadInt();
                int color = serializer.ReadInt();
                materials.Add(new PeltzerMaterial(materialId, color));
            }
            int meshCount = serializer.ReadCount(0, SerializationConsts.MAX_MESHES_PER_FILE, "meshCount");
            serializer.FinishReadingChunk(SerializationConsts.CHUNK_PELTZER);

            // Read meshes.
            meshes = new List<MMesh>();
            for (int i = 0; i < meshCount; i++)
            {
                meshes.Add(new MMesh(serializer));
            }

            // If the recommended model rotation is present (it's optional), read it.
            if (serializer.GetNextChunkLabel() == SerializationConsts.CHUNK_PELTZER_EXT_MODEL_ROTATION)
            {
                serializer.StartReadingChunk(SerializationConsts.CHUNK_PELTZER_EXT_MODEL_ROTATION);
                metadata.recommendedRotation = serializer.ReadFloat();
                serializer.FinishReadingChunk(SerializationConsts.CHUNK_PELTZER_EXT_MODEL_ROTATION);
            }
        }
    }

    // Basic metadata about a Peltzer file.
    public class Metadata
    {
        public string creatorName;
        public string creationDate;
        public string version;
        public float recommendedRotation;
        public Metadata(string creatorName, string creationDate, string version)
        {
            this.creatorName = creatorName; this.creationDate = creationDate; this.version = version;
            this.recommendedRotation = 0f;
        }
    }

    // A material used in a Peltzer file.
    public class PeltzerMaterial
    {
        // oneof materialId/color
        public int materialId;
        public int color; // e.g. 0xF06292
        public PeltzerMaterial(int materialId) { this.materialId = materialId; }
        public PeltzerMaterial(int color, bool ignored) { this.color = color; }
        public PeltzerMaterial(int materialId, int color) { this.materialId = materialId; this.color = color; }
    }
}
